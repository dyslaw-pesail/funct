
    Core issues:
    ============

    1. Everything is a function of type
            
        [Func] Func -> Func

    2. Memory management consists of fast page-aligned func allocs and 
       unsophisticated garbage collector simply checking pointer references and consolidating pages by copying.


    Language syntax and semantics:
    ==============================

    Definition :=  new DefinitionLine (...)
    DefinitionLine := Identifier<MatchExpression> MatchExpression -> Expression
    Expresion  :=  FunctionCall | FunctionClosure | Pair
    Expression :=  (Expression)
    Expression :=  Expression Expression
    FunctionCall    := Identifier Expression
    FunctionClosure := Identifier<Expression>
    Pair            := [Expression, Expression]
    

    Example:

    new hello<> Arg -> hello (dec Arg)

    new program<Env> Arg -> [
        hello 10, [
        print (fib 10),
        exit<0>
    ]]

    ------------------------------------------
    Integers are instances of function nofunc:
        nofunc<#10> -> nofunc<#10>
      

    ------------------------------------------
    How should match work?

    new match_test<10> A -> 1
        match_test<C> [X, match_test<X>] -> 2
        match_test<C> [X, Y] -> 3
        match_test<C> A -> 4

    local[C] := C
    local[A] := A
    if local[C] == 10 -> 1
    else if local[A] == list<> and local[X] := local[A] 0 and local[A] 1 == match_test<local[X]> -> 2
    else if local[A] == list<> and local[X] := local[A] 0 and local[Y] := local[A] 1 -> 3
    else -> 4

    MatchExpression := Variable |
                       ConstIdentifier |
                       Identifier<> |
                       Identifier<MatchExpression> |
                       [MatchExpression, MatchExpression]

                                                       

        
    Example:
    
    new fib<[A1, A2]> 0 -> A2
        fib<[A1, A2]> N -> fib<[A2, add [A1, A2]]> dec N


    new if<[B1, B2]> 0 -> B1
        if<[B1, B2]> A -> B2


